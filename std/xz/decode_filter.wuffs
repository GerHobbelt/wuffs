// Copyright 2023 The Wuffs Authors.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
//
// SPDX-License-Identifier: Apache-2.0 OR MIT

pri func decoder.apply_non_final_filters!(dst_slice: slice base.u8) base.u8,
        choosy,
{
    var f          : base.u32[..= 2]
    var i          : base.u64
    var filter_id  : base.u32[..= 0x7F]
    var delta_dist : base.u32[..= 0x100]
    var delta_pos  : base.u32
    var c8         : base.u8

    if this.num_non_final_filters <= 0 {
        return 0
    }
    f = this.num_non_final_filters - 1

    while true {
        filter_id = this.filters[f] & 0x7F
        if filter_id == 0x03 {  // Delta.
            delta_dist = ((this.filters[f] >> 8) & 0xFF) + 1
            delta_pos = this.filters[f] >> 24
            i = 0
            while i < args.dst_slice.length() {
                assert i < 0xFFFF_FFFF_FFFF_FFFF via "a < b: a < c; c <= b"(c: args.dst_slice.length())
                c8 = args.dst_slice[i]
                c8 ~mod+= this.filter_data[f][(delta_dist ~mod+ delta_pos) & 0xFF]
                this.filter_data[f][delta_pos & 0xFF] = c8
                delta_pos ~mod-= 1
                args.dst_slice[i] = c8
                i += 1
            } endwhile
            this.filters[f] &= 0xFFFF
            this.filters[f] |= (delta_pos ~mod<< 24)
        }

        if f <= 0 {
            break
        }
        f -= 1
    } endwhile
    return 0
}

pri func decoder.apply_filter_07_arm!(dst_slice: slice base.u8) base.u8 {
    return 0
}
