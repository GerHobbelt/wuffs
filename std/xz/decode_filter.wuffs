// Copyright 2023 The Wuffs Authors.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
//
// SPDX-License-Identifier: Apache-2.0 OR MIT

pri func decoder.apply_non_final_filters!(dst_slice: slice base.u8) base.u8,
        choosy,
{
    var f          : base.u32[..= 2]
    var i          : base.u64
    var filter_id  : base.u32[..= 0x7F]
    var delta_dist : base.u32[..= 0x100]
    var delta_pos  : base.u32
    var c8         : base.u8

    if this.num_non_final_filters <= 0 {
        return 0
    }
    f = this.num_non_final_filters - 1

    while true {
        filter_id = this.filters[f] & 0x7F
        if filter_id == 0x03 {  // Delta.
            delta_dist = ((this.filters[f] >> 8) & 0xFF) + 1
            delta_pos = this.filters[f] >> 24
            i = 0
            while i < args.dst_slice.length() {
                assert i < 0xFFFF_FFFF_FFFF_FFFF via "a < b: a < c; c <= b"(c: args.dst_slice.length())
                c8 = args.dst_slice[i]
                c8 ~mod+= this.filter_data[f][(delta_dist ~mod+ delta_pos) & 0xFF]
                this.filter_data[f][delta_pos & 0xFF] = c8
                delta_pos ~mod-= 1
                args.dst_slice[i] = c8
                i += 1
            } endwhile
            this.filters[f] &= 0xFFFF
            this.filters[f] |= (delta_pos ~mod<< 24)
        }

        if f <= 0 {
            break
        }
        f -= 1
    } endwhile
    return 0
}

pri func decoder.apply_filter_07_arm!(dst_slice: slice base.u8) base.u8 {
    var s : slice base.u8
    var p : base.u32
    var x : base.u32

    s = args.dst_slice
    p = this.bcj_pos ~mod+ 8

    while s.length() >= 4,
            post s.length() < 4,
    {
        if s[3] == 0xEB {
            x = ((s[0] as base.u32) << 0x00) |
                    ((s[1] as base.u32) << 0x08) |
                    ((s[2] as base.u32) << 0x10) |
                    ((s[3] as base.u32) << 0x18)
            x = (((x & 0xFF_FFFF) << 2) ~mod- p) >> 2
            s[0] = ((x >> 0x00) & 0xFF) as base.u8
            s[1] = ((x >> 0x08) & 0xFF) as base.u8
            s[2] = ((x >> 0x10) & 0xFF) as base.u8
        }
        p ~mod+= 4
        s = s[4 ..]
    } endwhile

    this.bcj_pos = p ~mod- 8
    return s.length() as base.u8
}

pri func decoder.apply_filter_08_armthumb!(dst_slice: slice base.u8) base.u8 {
    var s : slice base.u8
    var p : base.u32
    var x : base.u32
    var y : base.u32

    s = args.dst_slice
    p = this.bcj_pos ~mod+ 4

    while s.length() >= 4,
            post s.length() < 4,
    {
        x = ((s[0] as base.u32) << 0x00) |
                ((s[1] as base.u32) << 0x08) |
                ((s[2] as base.u32) << 0x10) |
                ((s[3] as base.u32) << 0x18)
        if (x & 0xF800_F800) <> 0xF800_F000 {
            p ~mod+= 2
            s = s[2 ..]
            continue
        }
        y = (((s[0] & 0xFF) as base.u32) << 0x0B) |
                (((s[1] & 0x07) as base.u32) << 0x13) |
                (((s[2] & 0xFF) as base.u32) << 0x00) |
                (((s[3] & 0x07) as base.u32) << 0x08)
        y = ((y ~mod<< 1) ~mod- p) >> 1
        s[0] = (((y >> 0x0B) & 0xFF)) as base.u8
        s[1] = (((y >> 0x13) & 0x07) | 0xF0) as base.u8
        s[2] = (((y >> 0x00) & 0xFF)) as base.u8
        s[3] = (((y >> 0x08) & 0x07) | 0xF8) as base.u8
        p ~mod+= 4
        s = s[4 ..]
    } endwhile

    this.bcj_pos = p ~mod- 4
    return s.length() as base.u8
}

pri func decoder.apply_filter_09_sparc!(dst_slice: slice base.u8) base.u8 {
    var s : slice base.u8
    var p : base.u32
    var x : base.u32

    s = args.dst_slice
    p = this.bcj_pos

    while s.length() >= 4,
            post s.length() < 4,
    {
        x = ((s[0] as base.u32) << 0x18) |
                ((s[1] as base.u32) << 0x10) |
                ((s[2] as base.u32) << 0x08) |
                ((s[3] as base.u32) << 0x00)
        if ((x >> 22) == 0x100) or ((x >> 22) == 0x1FF) {
            x = ((x ~mod<< 2) ~mod- p) >> 2
            x = (0x4000_0000 - (x & 0x40_0000)) | 0x4000_0000 | (x & 0x3F_FFFF)
            s[0] = ((x >> 0x18) & 0xFF) as base.u8
            s[1] = ((x >> 0x10) & 0xFF) as base.u8
            s[2] = ((x >> 0x08) & 0xFF) as base.u8
            s[3] = ((x >> 0x00) & 0xFF) as base.u8
        }
        p ~mod+= 4
        s = s[4 ..]
    } endwhile

    this.bcj_pos = p
    return s.length() as base.u8
}

pri func decoder.apply_filter_0a_arm64!(dst_slice: slice base.u8) base.u8 {
    var s : slice base.u8
    var p : base.u32
    var x : base.u32
    var y : base.u32

    s = args.dst_slice
    p = this.bcj_pos

    while s.length() >= 4,
            post s.length() < 4,
    {
        x = ((s[0] as base.u32) << 0x00) |
                ((s[1] as base.u32) << 0x08) |
                ((s[2] as base.u32) << 0x10) |
                ((s[3] as base.u32) << 0x18)
        if (x >> 26) == 0x25 {
            // Arm64 BL instruction.
            y = x ~mod- (p >> 2)
            x = 0x9400_0000 | (y & 0x03FF_FFFF)
            s[0] = ((x >> 0x00) & 0xFF) as base.u8
            s[1] = ((x >> 0x08) & 0xFF) as base.u8
            s[2] = ((x >> 0x10) & 0xFF) as base.u8
            s[3] = ((x >> 0x18) & 0xFF) as base.u8
        } else if (x & 0x9F00_0000) == 0x9000_0000 {
            // Arm64 ADRP instruction. We only modify relative addresses in the
            // range +/-512 MiB.
            y = ((x >> 29) & 0x03) | ((x >> 3) & 0x1F_FFFC)
            if ((y ~mod+ 0x02_0000) & 0x1C_0000) == 0 {
                y ~mod-= p >> 12
                x &= 0x9000_001F
                x |= (y & 3) << 29
                x |= (y & 0x03_FFFC) << 3
                x |= (0 ~mod- (y & 0x02_0000)) & 0xE0_0000
                s[0] = ((x >> 0x00) & 0xFF) as base.u8
                s[1] = ((x >> 0x08) & 0xFF) as base.u8
                s[2] = ((x >> 0x10) & 0xFF) as base.u8
                s[3] = ((x >> 0x18) & 0xFF) as base.u8
            }
        }
        p ~mod+= 4
        s = s[4 ..]
    } endwhile

    this.bcj_pos = p
    return s.length() as base.u8
}
