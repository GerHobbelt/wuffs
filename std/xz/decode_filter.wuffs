// Copyright 2023 The Wuffs Authors.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
//
// SPDX-License-Identifier: Apache-2.0 OR MIT

pri func decoder.apply_non_final_filters!(dst_slice: slice base.u8) base.u8,
        choosy,
{
    var f          : base.u32[..= 2]
    var i          : base.u64
    var filter_id  : base.u32[..= 0x7F]
    var delta_dist : base.u32[..= 0x100]
    var delta_pos  : base.u32
    var c8         : base.u8

    if this.num_non_final_filters <= 0 {
        return 0
    }
    f = this.num_non_final_filters - 1

    while true {
        filter_id = this.filters[f] & 0x7F
        if filter_id == 0x03 {  // Delta.
            delta_dist = ((this.filters[f] >> 8) & 0xFF) + 1
            delta_pos = this.filters[f] >> 24
            i = 0
            while i < args.dst_slice.length() {
                assert i < 0xFFFF_FFFF_FFFF_FFFF via "a < b: a < c; c <= b"(c: args.dst_slice.length())
                c8 = args.dst_slice[i]
                c8 ~mod+= this.filter_data[f][(delta_dist ~mod+ delta_pos) & 0xFF]
                this.filter_data[f][delta_pos & 0xFF] = c8
                delta_pos ~mod-= 1
                args.dst_slice[i] = c8
                i += 1
            } endwhile
            this.filters[f] &= 0xFFFF
            this.filters[f] |= (delta_pos ~mod<< 24)
        }

        if f <= 0 {
            break
        }
        f -= 1
    } endwhile
    return 0
}

pri func decoder.apply_filter_07_arm!(dst_slice: slice base.u8) base.u8 {
    var s : slice base.u8
    var p : base.u32
    var x : base.u32

    s = args.dst_slice
    p = this.bcj_pos ~mod+ 8

    while s.length() >= 4,
            post s.length() < 4,
    {
        if s[3] == 0xEB {
            x = ((s[0] as base.u32) << 0x00) |
                    ((s[1] as base.u32) << 0x08) |
                    ((s[2] as base.u32) << 0x10) |
                    ((s[3] as base.u32) << 0x18)
            x = (((x & 0xFF_FFFF) << 2) ~mod- p) >> 2
            s[0] = ((x >> 0x00) & 0xFF) as base.u8
            s[1] = ((x >> 0x08) & 0xFF) as base.u8
            s[2] = ((x >> 0x10) & 0xFF) as base.u8
        }
        p ~mod+= 4
        s = s[4 ..]
    } endwhile

    this.bcj_pos = p ~mod- 8
    return s.length() as base.u8
}
