// Copyright 2023 The Wuffs Authors.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// https://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

pri func hasher.up_x86_sse42!(x: roslice base.u8),
        choose cpu_arch >= x86_sse42,
{
    // These variables are the same as the non-SIMD version.
    var new_lmu : base.u32
    var buf_u32 : base.u32
    var buf_len : base.u32[..= 15]
    var v0      : base.u32
    var v1      : base.u32
    var v2      : base.u32
    var v3      : base.u32
    var p       : roslice base.u8

    // The remaining variables are specific to the SIMD version.

    var util   : base.x86_sse42_utility
    var v      : base.x86_m128i
    var prime1 : base.x86_m128i
    var prime2 : base.x86_m128i
    var tail   : base.u64

    new_lmu = this.length_modulo_u32 ~mod+ ((args.x.length() & 0xFFFF_FFFF) as base.u32)
    this.length_overflows_u32 = (new_lmu < this.length_modulo_u32) or this.length_overflows_u32
    this.length_modulo_u32 = new_lmu

    while true {
        if this.buf_len >= 16 {
            buf_u32 = (this.buf_data[0x00] as base.u32) |
                    ((this.buf_data[0x01] as base.u32) << 8) |
                    ((this.buf_data[0x02] as base.u32) << 16) |
                    ((this.buf_data[0x03] as base.u32) << 24)
            v0 = this.v0 ~mod+ (buf_u32 ~mod* XXH_PRIME32_2)
            v0 = (v0 ~mod<< 13) | (v0 >> 19)
            this.v0 = v0 ~mod* XXH_PRIME32_1

            buf_u32 = (this.buf_data[0x04] as base.u32) |
                    ((this.buf_data[0x05] as base.u32) << 8) |
                    ((this.buf_data[0x06] as base.u32) << 16) |
                    ((this.buf_data[0x07] as base.u32) << 24)
            v1 = this.v1 ~mod+ (buf_u32 ~mod* XXH_PRIME32_2)
            v1 = (v1 ~mod<< 13) | (v1 >> 19)
            this.v1 = v1 ~mod* XXH_PRIME32_1

            buf_u32 = (this.buf_data[0x08] as base.u32) |
                    ((this.buf_data[0x09] as base.u32) << 8) |
                    ((this.buf_data[0x0A] as base.u32) << 16) |
                    ((this.buf_data[0x0B] as base.u32) << 24)
            v2 = this.v2 ~mod+ (buf_u32 ~mod* XXH_PRIME32_2)
            v2 = (v2 ~mod<< 13) | (v2 >> 19)
            this.v2 = v2 ~mod* XXH_PRIME32_1

            buf_u32 = (this.buf_data[0x0C] as base.u32) |
                    ((this.buf_data[0x0D] as base.u32) << 8) |
                    ((this.buf_data[0x0E] as base.u32) << 16) |
                    ((this.buf_data[0x0F] as base.u32) << 24)
            v3 = this.v3 ~mod+ (buf_u32 ~mod* XXH_PRIME32_2)
            v3 = (v3 ~mod<< 13) | (v3 >> 19)
            this.v3 = v3 ~mod* XXH_PRIME32_1

            this.buf_len = 0
            break
        }

        if args.x.length() <= 0 {
            return nothing
        }
        this.buf_data[this.buf_len] = args.x[0]
        this.buf_len += 1
        args.x = args.x[1 ..]
    } endwhile

    v = util.make_m128i_multiple_u32(
            a00: this.v0, a01: this.v1, a02: this.v2, a03: this.v3)
    prime1 = util.make_m128i_repeat_u32(a: XXH_PRIME32_1)
    prime2 = util.make_m128i_repeat_u32(a: XXH_PRIME32_2)

    iterate (p = args.x)(length: 16, advance: 16, unroll: 1) {
        v = v._mm_add_epi32(b:
                util.make_m128i_slice128(a: p)._mm_mullo_epi32(b: prime2))
        v = v._mm_slli_epi32(imm8: 13)._mm_or_si128(b:
                v._mm_srli_epi32(imm8: 19))
        v = v._mm_mullo_epi32(b: prime1)
    }

    this.v0 = v._mm_extract_epi32(imm8: 0)
    this.v1 = v._mm_extract_epi32(imm8: 1)
    this.v2 = v._mm_extract_epi32(imm8: 2)
    this.v3 = v._mm_extract_epi32(imm8: 3)

    tail = args.x.length() & 0xFFFF_FFFF_FFFF_FFF0
    if tail < args.x.length() {
        buf_len = (this.buf_len & 15) as base.u32
        iterate (p = args.x[tail ..])(length: 1, advance: 1, unroll: 1) {
            this.buf_data[buf_len] = p[0]
            buf_len = (buf_len + 1) & 15
        }
        this.buf_len = buf_len as base.u8
    }
}
